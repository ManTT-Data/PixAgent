# PIX Project Backend API Documentation

## Base URL

```
https://huggingface.co/spaces/Cuong2004/Pix-Agent/
```

For local development:
```
http://localhost:7860/
```

## Authentication

Currently, the API does not require authentication.

## Common Status Codes

- `200 OK`: Request successful
- `201 Created`: Resource created successfully
- `400 Bad Request`: Invalid request parameters
- `404 Not Found`: Resource not found
- `422 Unprocessable Entity`: Validation error
- `500 Internal Server Error`: Server-side error

## API Endpoints

## Core Endpoints

### Root Endpoint

```
GET /
```

**Response**:
```json
{
  "message": "Welcome to PIX Project Backend API",
  "documentation": "/docs"
}
```

### Health Check

```
GET /health
```

**Response**:
```json
{
  "status": "healthy",
  "version": "1.0.0",
  "environment": "production",
  "databases": {
    "postgresql": true,
    "mongodb": true,
    "pinecone": true
  }
}
```

## MongoDB Endpoints

### Create Session

```
POST /mongodb/session
```

**Request Body**:
```json
{
  "session_id": "string",
  "factor": "string",
  "action": "string",
  "message": "string",
  "user_id": "string",
  "username": "string",
  "first_name": "string",
  "last_name": "string",
  "response": "string"
}
```

**Response**:
```json
{
  "session_id": "string",
  "created_at": "string",
  "factor": "string",
  "action": "string",
  "message": "string",
  "user_id": "string",
  "username": "string",
  "first_name": "string",
  "last_name": "string",
  "response": "string"
}
```

### Get Session

```
GET /mongodb/session/{session_id}
```

**Parameters**:
- `session_id`: Session ID (path parameter)

**Response**:
```json
{
  "session_id": "string",
  "created_at": "string",
  "factor": "string",
  "action": "string",
  "message": "string",
  "user_id": "string",
  "username": "string",
  "first_name": "string",
  "last_name": "string",
  "response": "string"
}
```

### Update Session Response

```
PUT /mongodb/session/{session_id}/response
```

**Parameters**:
- `session_id`: Session ID (path parameter)
- `response_text`: Response text (query parameter)

**Response**:
```json
{
  "status": "success",
  "message": "Response updated successfully",
  "session_id": "string"
}
```

### Get User History

```
GET /mongodb/history
```

**Parameters**:
- `user_id`: User ID (query parameter)
- `n`: Number of history items to retrieve (query parameter, default: 3)

**Response**:
```json
{
  "history": [
    {
      "question": "string",
      "answer": "string"
    }
  ]
}
```

### MongoDB Health Check

```
GET /mongodb/health
```

**Response**:
```json
{
  "status": "healthy",
  "timestamp": "2023-09-15T12:34:56"
}
```

## PostgreSQL Endpoints

### FAQ Endpoints

#### Get FAQ Items

```
GET /postgres/faq
```

**Parameters**:
- `skip`: Items to skip (query parameter, default: 0)
- `limit`: Maximum items to return (query parameter, default: 100)

**Response**:
```json
[
  {
    "id": 1,
    "question": "string",
    "answer": "string",
    "is_active": true,
    "created_at": "2023-09-15T12:34:56",
    "updated_at": "2023-09-15T12:34:56"
  }
]
```

#### Create FAQ Item

```
POST /postgres/faq
```

**Request Body**:
```json
{
  "question": "string",
  "answer": "string",
  "is_active": true
}
```

**Response**:
```json
{
  "id": 1,
  "question": "string",
  "answer": "string",
  "is_active": true,
  "created_at": "2023-09-15T12:34:56",
  "updated_at": "2023-09-15T12:34:56"
}
```

#### Get FAQ Item

```
GET /postgres/faq/{faq_id}
```

**Parameters**:
- `faq_id`: FAQ ID (path parameter)

**Response**:
```json
{
  "id": 1,
  "question": "string",
  "answer": "string",
  "is_active": true,
  "created_at": "2023-09-15T12:34:56",
  "updated_at": "2023-09-15T12:34:56"
}
```

#### Update FAQ Item

```
PUT /postgres/faq/{faq_id}
```

**Parameters**:
- `faq_id`: FAQ ID (path parameter)

**Request Body**:
```json
{
  "question": "string",
  "answer": "string",
  "is_active": true
}
```

**Response**:
```json
{
  "id": 1,
  "question": "string",
  "answer": "string",
  "is_active": true,
  "created_at": "2023-09-15T12:34:56",
  "updated_at": "2023-09-15T12:34:56"
}
```

#### Delete FAQ Item

```
DELETE /postgres/faq/{faq_id}
```

**Parameters**:
- `faq_id`: FAQ ID (path parameter)

**Response**:
```json
{
  "status": "success",
  "message": "FAQ item deleted successfully"
}
```

### Emergency Contact Endpoints

#### Get Emergency Contacts

```
GET /postgres/emergency
```

**Parameters**:
- `skip`: Items to skip (query parameter, default: 0)
- `limit`: Maximum items to return (query parameter, default: 100)

**Response**:
```json
[
  {
    "id": 1,
    "name": "string",
    "phone_number": "string",
    "description": "string",
    "is_active": true,
    "created_at": "2023-09-15T12:34:56",
    "updated_at": "2023-09-15T12:34:56"
  }
]
```

#### Create Emergency Contact

```
POST /postgres/emergency
```

**Request Body**:
```json
{
  "name": "string",
  "phone_number": "string",
  "description": "string",
  "is_active": true
}
```

**Response**:
```json
{
  "id": 1,
  "name": "string",
  "phone_number": "string",
  "description": "string",
  "is_active": true,
  "created_at": "2023-09-15T12:34:56",
  "updated_at": "2023-09-15T12:34:56"
}
```

#### Get Emergency Contact

```
GET /postgres/emergency/{emergency_id}
```

**Parameters**:
- `emergency_id`: Emergency contact ID (path parameter)

**Response**:
```json
{
  "id": 1,
  "name": "string",
  "phone_number": "string",
  "description": "string",
  "is_active": true,
  "created_at": "2023-09-15T12:34:56",
  "updated_at": "2023-09-15T12:34:56"
}
```

### Event Endpoints

#### Get Events

```
GET /postgres/events
```

**Parameters**:
- `skip`: Items to skip (query parameter, default: 0)
- `limit`: Maximum items to return (query parameter, default: 100)

**Response**:
```json
[
  {
    "id": 1,
    "name": "string",
    "description": "string",
    "address": "string",
    "date_start": "2023-09-15T12:34:56",
    "date_end": "2023-09-15T12:34:56",
    "is_active": true,
    "featured": false,
    "price": [
      {
        "type": "string",
        "amount": 0,
        "currency": "string"
      }
    ],
    "created_at": "2023-09-15T12:34:56",
    "updated_at": "2023-09-15T12:34:56"
  }
]
```

### PostgreSQL Health Check

```
GET /postgres/health
```

**Response**:
```json
{
  "status": "healthy",
  "version": "PostgreSQL 14.5",
  "tables": ["faq_item", "emergency_contact", "event"]
}
```

## RAG Endpoints

### Generate Embedding

```
POST /rag/embedding
```

**Request Body**:
```json
{
  "text": "string"
}
```

**Response**:
```json
{
  "embedding": [0.1, 0.2, 0.3, ...],
  "text": "string",
  "model": "embedding-001"
}
```

### RAG Chat

```
POST /rag/chat
```

**Request Body**:
```json
{
  "user_id": "string",
  "question": "string",
  "include_history": true,
  "use_rag": true,
  "similarity_top_k": 3,
  "vector_distance_threshold": 0.75,
  "session_id": "string",
  "first_name": "string",
  "last_name": "string",
  "username": "string"
}
```

**Response**:
```json
{
  "answer": "string",
  "processing_time": 1.23
}
```

**Note**: 
- RAG chat will automatically save the answer to MongoDB for the given session_id.
- The response no longer includes source documents for better performance and lighter payload.
- All source documents are still logged on the server for debugging purposes.

### RAG Health Check

```
GET /rag/health
```

**Response**:
```json
{
  "status": "healthy",
  "services": {
    "gemini": true,
    "pinecone": true
  },
  "timestamp": "2023-09-15T12:34:56"
}
```

## WebSocket API

### WebSocket Connection Information

To connect to the WebSocket API, use the following URL:

```
ws://{SERVER}:{PORT}/notify
```

For secure connections (HTTPS):
```
wss://{SERVER}/notify
```

For detailed WebSocket connection information, including examples and instructions:

```
GET /notify
```

**Response**:
```json
{
  "websocket_endpoint": "/notify",
  "connection_type": "WebSocket",
  "protocol": "ws://",
  "server": "localhost",
  "port": "7860",
  "full_url": "ws://localhost:7860/notify",
  "description": "Endpoint nhận thông báo về các session mới cần chú ý",
  "notification_format": {
    "type": "new_session",
    "timestamp": "YYYY-MM-DD HH:MM:SS",
    "data": {
      "session_id": "id của session",
      "factor": "user",
      "action": "loại hành động",
      "message": "Câu hỏi người dùng",
      "response": "I don't know...",
      "user_id": "id người dùng",
      "first_name": "tên người dùng",
      "last_name": "họ người dùng",
      "username": "tên đăng nhập",
      "created_at": "thời gian tạo"
    }
  },
  "client_example": "..."
}
```

### Notifications for New Sessions

```
WebSocket /notify
```

**When are notifications sent?**
- When the system generates a response that starts with "I don't know"
- The original user question and the response are both included in the notification

**Key WebSocket Client Requirements:**
- Send "keepalive" messages every 5 minutes to maintain connection
- Implement automatic reconnection logic
- Use ping/pong for connection monitoring (ping_interval=60, ping_timeout=30)

**Notification Format**:
```json
{
  "type": "new_session",
  "timestamp": "2023-09-15T12:34:56",
  "data": {
    "session_id": "string",
    "factor": "user",
    "action": "string",
    "created_at": "string",
    "first_name": "string",
    "last_name": "string",
    "message": "string",
    "response": "I don't know...",
    "user_id": "string",
    "username": "string"
  }
}
```

**Recommended WebSocket Client Implementation:**

```python
import websocket
import json
import os
import time
import threading
import logging
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("WebSocketClient")

# Load environment variables
load_dotenv()

# WebSocket configuration
WEBSOCKET_SERVER = os.getenv("WEBSOCKET_SERVER", "localhost")
WEBSOCKET_PORT = os.getenv("WEBSOCKET_PORT", "7860")
WEBSOCKET_PATH = os.getenv("WEBSOCKET_PATH", "/notify")
USE_WSS = os.getenv("USE_WSS", "False").lower() in ("true", "1", "t")

# Create full URL based on protocol
if USE_WSS:
    # For HTTPS deployments (HuggingFace, Render, etc.)
    ws_url = f"wss://{WEBSOCKET_SERVER}{WEBSOCKET_PATH}"
else:
    # For HTTP deployments (local, direct port access)
    ws_url = f"ws://{WEBSOCKET_SERVER}:{WEBSOCKET_PORT}{WEBSOCKET_PATH}"

# Send keepalive messages periodically
def send_keepalive(ws):
    while True:
        try:
            if ws.sock and ws.sock.connected:
                ws.send("keepalive")
                logger.info("Sent keepalive message")
            time.sleep(300)  # 5 minutes
        except Exception as e:
            logger.error(f"Error sending keepalive: {e}")
            time.sleep(60)

# WebSocket event handlers
def on_message(ws, message):
    try:
        # Try to parse as JSON
        data = json.loads(message)
        logger.info(f"Received notification: {data}")
        
        # Process notification
        if data.get("type") == "new_session":
            session_data = data.get("data", {})
            user_question = session_data.get("message", "")
            user_response = session_data.get("response", "")
            user_name = session_data.get("first_name", "Unknown User")
            
            # Log the question that couldn't be answered
            logger.info(f"User {user_name} asked: {user_question}")
            logger.info(f"System response: {user_response}")
            
            # Forward to Telegram admin group
            # telegram_bot.send_message(
            #    chat_id=ADMIN_GROUP_ID,
            #    text=f"❓ *Question from {user_name}*:\n{user_question}\n\n" +
            #         f"🤖 *AI response*:\n{user_response}",
            #    parse_mode="Markdown"
            # )
    except json.JSONDecodeError:
        # Handle non-JSON messages (like keepalive responses)
        logger.debug(f"Received non-JSON message: {message}")
    except Exception as e:
        logger.error(f"Error processing message: {e}")

def on_error(ws, error):
    logger.error(f"WebSocket error: {error}")

def on_close(ws, close_status_code, close_msg):
    logger.warning(f"WebSocket connection closed: code={close_status_code}, message={close_msg}")

def on_open(ws):
    logger.info(f"WebSocket connection opened to {ws_url}")
    # Start keepalive thread
    keepalive_thread = threading.Thread(target=send_keepalive, args=(ws,), daemon=True)
    keepalive_thread.start()

# Main function to run WebSocket with reconnection logic
def run_websocket_client():
    while True:
        try:
            # Connect to WebSocket with ping/pong for connection monitoring
            ws = websocket.WebSocketApp(
                ws_url,
                on_open=on_open,
                on_message=on_message,
                on_error=on_error,
                on_close=on_close
            )
            
            # Run with ping/pong enabled
            ws.run_forever(ping_interval=60, ping_timeout=30)
            
            # If we get here, connection was closed
            logger.warning("WebSocket connection lost, reconnecting in 5 seconds...")
            time.sleep(5)
        except Exception as e:
            logger.error(f"WebSocket client error: {e}")
            logger.info("Reconnecting in 5 seconds...")
            time.sleep(5)

# Start the WebSocket client in a background thread
websocket_thread = threading.Thread(target=run_websocket_client, daemon=True)
websocket_thread.start()

# Keep the main thread running
try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    logger.info("Stopping WebSocket client...")
```

## Error Responses

In case of errors, the API returns a JSON object with the following structure:

```json
{
  "detail": "Error message"
}
```

For validation errors:

```json
{
  "detail": [
    {
      "loc": ["body", "field_name"],
      "msg": "field required",
      "type": "value_error.missing"
    }
  ]
}
```

## API Documentation

For more detailed API documentation with schema information, visit:

```
GET /docs
```

For ReDoc alternative documentation:

```
GET /redoc
``` 